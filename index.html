<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Retro Ship Scan Interface - Three.js</title>
  <style>
    :root {
      --bg: #000000;
      --glow: #ffaa00;
      --text: #ffaa00;
    }

 .target-ui {
  position: absolute;
  background: rgba(0, 0, 0, 0.75);
  border: 2px solid var(--glow);
  padding: 6px 12px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  pointer-events: none;
  color: var(--text);
  text-shadow: 0 0 6px var(--glow);
  z-index: 1001;
  animation: glitch-pulse 0.5s infinite steps(2, end);
  line-height: 1.4;
}

  
@keyframes glitch-pulse {
  0%   { opacity: 0.9; transform: translate(0, 0); }
  25%  { transform: translate(1px, -1px); }
  50%  { transform: translate(-1px, 1px); }
  75%  { transform: translate(1px, 1px); }
  100% { opacity: 0.9; transform: translate(0, 0); }
}


.target-ui.hidden {
  display: none;
}

    .foreign-text::after {
  content: '';
  position: absolute;
  top: 50%;
  right: -12px;
  border-width: 6px;
  border-style: solid;
  border-color: transparent transparent transparent var(--glow);
  transform: translateY(-50%);
}


    .overlay {
  opacity: 0;
  transition: opacity 0.5s ease;
}


.target-label {
  font-size: 10px;
  letter-spacing: 0.15em;
  opacity: 0.7;
}

.target-type {
  font-size: 14px;
  margin-top: 4px;
  font-weight: bold;
}


.target-name {
  font-size: 18px;
  margin-top: 2px;
}

.target-info {
  font-size: 12px;
  margin-top: 4px;
  opacity: 0.8;
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
  50% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
}

    body {
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      font-family: 'IBM Plex Mono', monospace;
      color: var(--text);
      transition: background 1.5s ease, color 1.5s ease;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 0 12px var(--glow));
      transition: filter 1.5s ease;
    }

    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 14px;
      color: var(--text);
      text-shadow: 0 0 4px var(--glow);
      transition: color 1.5s ease, text-shadow 1.5s ease;
      z-index: 1000;
    }

    #codeStream {
      color: var(--text);
      text-shadow: 0 0 1px var(--glow);
      font-size: 4px;
      opacity: 0.9;
      font-family: 'IBM Plex Mono', monospace;
      position: fixed;
      bottom: 6px;
      left: 6px;
      z-index: 1000;
      max-width: 140px;
      overflow: hidden;
      text-align: left;
    }

    html, body {
  height: 100%;
}

#globeContainer {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

    #loadingScreen {
  background: #000;
  color: #ffaa00;
  font-family: 'IBM Plex Mono', monospace;
  letter-spacing: 0.15em;
  font-size: 12px;
  text-shadow: 0 0 4px #ffaa00;
  animation: flicker 1s infinite;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 9999;
  pointer-events: none;
}

@keyframes flicker {
  0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
    opacity: 1;
  }
  20%, 24%, 55% {
    opacity: 0.5;
  }
}

#progressBarContainer {
  width: 240px;
  height: 8px;
  border: 1px solid var(--glow);
  box-shadow: 0 0 3px var(--glow);
  background: linear-gradient(to right, rgba(255,170,0,0.1) 0%, rgba(0,0,0,0.1) 100%);
  margin-top: 20px;
  position: relative;
  overflow: hidden;
}

#progressBar {
  width: 0%;
  height: 100%;
  background: var(--glow);
  box-shadow: 0 0 12px var(--glow), 0 0 2px var(--glow) inset;
  transition: width 0.25s ease;
}

    .foreign-text {
  position: absolute;
  color: #ffaa00;
  background: rgba(0, 0, 0, 0.75);
  border: 2px solid #ffaa00;
  padding: 6px 12px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  pointer-events: none;
  text-shadow: 0 0 6px #ffaa00;
  animation: glitch-pulse 0.5s infinite steps(2, end);
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  line-height: 1.4;
}

.foreign-subheader {
  font-size: 11px;
}

.hidden {
  display: none;
}


#loadingText {
  font-size: 12px;
  letter-spacing: 0.15em;
  color: var(--text);
  text-shadow: 0 0 3px var(--glow);
  font-family: 'Courier New', Courier, monospace;
  text-transform: uppercase;
  letter-spacing: 0.2em;
  animation: flicker 1.2s infinite;
}

    @keyframes glyph-spin {
      0%   { transform: scale(1) rotate(0deg); opacity: 0.6; }
      25%  { transform: scale(1.2) rotate(8deg); opacity: 1; }
      50%  { transform: scale(1) rotate(-8deg); opacity: 0.6; }
      75%  { transform: scale(1.1) rotate(4deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
    }
  </style>
</head>
<body>
  <div class="overlay">
    INTERFACE ONLINE...<br>
    TRACKING OBJECT<br>
    SIGNAL LOCKED<br>
    UNIT ID: A7-SCAN<br>
  </div>

  <div id="loadingScreen">
  <div id="loadingText">⚡ BOOTING SEQUENCE...</div>
  <div id="progressBarContainer">
    <div id="progressBar"></div>
  </div>
</div>

  <div id="targetUI" class="target-ui hidden">
  <div class="target-label">TARGET LOCKED</div>
  <div class="target-type">[ TYPE: ASTEROID ]</div>
  <div class="target-name">CERES-9</div>
  <div class="target-info">DISTANCE: 41,000 KM</div>
</div>

<div id="foreignAlert" class="foreign-text hidden">
  <div class="foreign-subheader">OBJECT DETECTED</div>
</div>

  <div id="globeContainer" style="width: 100%; height: 100%; position: relative;"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<pre id="codeStream"></pre>
  <script>
    let scene, camera, renderer, scanLines = [], scanStep = 0;
let sphereDots = [], scanTargets = [], connectorGroup, dotGroup;
let mouseX = 0, mouseY = 0, targetRotationX = 0, targetRotationY = 0;
let autoRotateY = 0.0015;
let autoRotateX = 0.00075;
let dotColor = new THREE.Color(0xffaa00);
let targetDotColor = dotColor.clone();
let connectorLinesBuilt = false;
let colorUpdateActive = false;
let theme = { bg: '#000', text: '#ffaa00', glow: '#ffaa00' };

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let targetDot;
let pivotGroup;
let orbitLine;
let trackingTarget = false;
let zoomLevel = 300; // default zoom
let desiredRotationX = 0;
let desiredRotationY = 0;
let dotOrbitAngle = 0;
let orbitRadius = 110;
let tracking = false;
let trackingInterrupted = false;
let trackingProgress = 0;
let unifiedGroup;
let gridLinesSphere;
let solidSphere;
let enableFrontCull = false;
let connectorLines = [];


    document.addEventListener("DOMContentLoaded", () => {
  document.getElementById("progressBar").style.width = "0%";
});
    
 const loadingTexts = [
  "POWER SUPPLY OK",
  "CPU DIAGNOSTIC... PASSED",
  "MEMORY BANKS... OK",
  "VGA INTERFACE... OK",
  "INITIATING BOOT SEQUENCE...",
  "LOADING OS KERNEL",
  "ACTIVATING SENSOR ARRAY",
  "CREATING DIGITAL ATMOSPHERE...",
  "ATMOSPHERE STABILIZED",
  "CALIBRATING OPTICS...",
  "OPTICS ALIGNED",
  "INITIATING WEATHER SCAN...",
  "SCANNING CLIMATE DATA",
  "PARSING METEOROLOGICAL READINGS...",
  "SCAN COMPLETE!",
  "INITIALIZING OBJECT SCAN...",
  "DETECTING FOREIGN OBJECTS...",
  "OBJECT SCAN: 38 TARGETS FOUND",
  "INITIALIZING PLANET LOAD...",
  "STELLAR COORDINATES LOCKED",
  "GRAVITY FIELD MAPPED",
  "NAV SYSTEM ONLINE",
  "STARTING UP...",
  "LOADING INTERFACE MODULE",
  "RENDER ENGINE READY",
  "FINAL SYSTEM CHECK...",
  "PROCESS COMPLETE"
];

    let gridSphereOpacity = 0.0;
    
function animateGridFadeIn() {
  if (gridSphereOpacity >= 0.1) return;
  gridSphereOpacity += 0.01;
  if (gridLinesSphere) {
    gridLinesSphere.material.opacity = gridSphereOpacity;
  }
  requestAnimationFrame(animateGridFadeIn);
}


    function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

    let isDragging = false;
let previousMousePosition = { x: 0, y: 0 };

function cycleLoadingText(callback) {
  const loadingTextElement = document.getElementById("loadingText");
  const bar = document.getElementById("progressBar");

  let index = 0;
  const total = loadingTexts.length;

  function next() {
    if (index >= total) {
      bar.style.width = 100%;
      if (callback) callback();
      return;
    }

    loadingTextElement.textContent = loadingTexts[index];
    bar.style.width = ${Math.floor(((index + 1) / total) * 100)}%;

    index++;
    setTimeout(next, 100); 
  }

  next();
}

    let weatherSignature = {
  mood: 'neutral',
  energy: 0.5, // visual intensity
  colorBias: 'warm', // or 'cool'
  clarity: 0.8, // 0 = foggy, 1 = sharp
  jitter: 0.0 // affects orbit motion, camera shake, etc
};


function getWeatherVisuals() {
  return fetch("https://ipapi.co/json/")
    .then(loc => loc.json())
    .then(location => {
      const city = location.city;
      return fetch(https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=d8c57f566aee63e2c23b71a879a8d2b7&units=metric);
    })
    .then(res => res.json())
    .then(data => {
      const hour = new Date().getHours();
      const isNight = hour < 6 || hour > 21;
      const condition = data.weather[0].main.toLowerCase();
      const temp = data.main.temp;
      const wind = data.wind.speed;
      const clouds = data.clouds.all;
      const pressure = data.main.pressure;

      // Interpret signature
      weatherSignature.energy = Math.min(wind / 15, 1); // speed-related
      weatherSignature.jitter = condition.includes('thunderstorm') ? 0.9 :
                                condition.includes('rain') ? 0.4 : 0.05;
      weatherSignature.clarity = 1 - clouds / 100;

      if (condition.includes("clear")) {
        weatherSignature.mood = isNight ? "serene-night" : "sunny";
        weatherSignature.colorBias = "warm";
      } else if (condition.includes("cloud")) {
        weatherSignature.mood = "overcast";
        weatherSignature.colorBias = "neutral";
      } else if (condition.includes("rain")) {
        weatherSignature.mood = "rainy";
        weatherSignature.colorBias = "cool";
      } else if (condition.includes("thunderstorm")) {
        weatherSignature.mood = "stormy";
        weatherSignature.colorBias = "warm";
      } else if (["fog", "mist", "haze"].includes(condition)) {
        weatherSignature.mood = "foggy";
        weatherSignature.colorBias = "cool";
        weatherSignature.clarity = 0.2;
      }

      // Color logic
      if (weatherSignature.colorBias === "cool") {
        targetDotColor.set(0x88ccff);
        theme.bg = '#02101c';
        theme.text = '#88ccff';
        theme.glow = '#44bbff';
      } else if (weatherSignature.colorBias === "warm") {
        targetDotColor.set(0xffaa66);
        theme.bg = '#1e0d00';
        theme.text = '#ffaa66';
        theme.glow = '#ff8833';
      } else {
        targetDotColor.set(0xffaa00);
        theme.bg = '#0f0f0f';
        theme.text = '#ffaa00';
        theme.glow = '#ffaa00';
      }

      // Apply theme
      document.documentElement.style.setProperty('--bg', theme.bg);
      document.documentElement.style.setProperty('--text', theme.text);
      document.documentElement.style.setProperty('--glow', theme.glow);

      console.log("WEATHER SIGNATURE:", weatherSignature);
    });
}

   function applyStencilMask(material) {
  material.stencilWrite = true;
material.stencilFunc = THREE.EqualStencilFunc;
  material.stencilRef = 1;
  material.stencilZPass = THREE.KeepStencilOp;
}

    function init() {
      scene = new THREE.Scene(); 
      const light = new THREE.AmbientLight(theme.text, 0.35);
scene.add(light);
     unifiedGroup = new THREE.Group();
scene.add(unifiedGroup);

const stencilWriteMaterial = new THREE.MeshBasicMaterial({
  colorWrite: false,
  depthWrite: true,
  depthTest: false,
  stencilWrite: true,
  stencilFunc: THREE.AlwaysStencilFunc,
  stencilRef: 1,
  stencilZPass: THREE.ReplaceStencilOp
});

      stencilWriteMaterial.colorWrite = false;
stencilWriteMaterial.transparent = true;
stencilWriteMaterial.opacity = 0.0;

solidSphere = new THREE.Mesh(
  new THREE.SphereGeometry(101.9, 64, 64),
  stencilWriteMaterial
);
solidSphere.frustumCulled = false;
scene.add(solidSphere); // ✅ put solidSphere in the root scene so it's rendered separately
      
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 300;

     const gridLinesMaterial = new THREE.MeshBasicMaterial({
  color: new THREE.Color(theme.glow),
  wireframe: true,
  transparent: false,
  opacity: 1.0,
  depthWrite: true,
  depthTest: true,
  side: THREE.FrontSide
});


gridLinesSphere = new THREE.Mesh(
  new THREE.SphereGeometry(102, 32, 32),
  gridLinesMaterial
);
      
solidSphere.renderOrder = 0;

solidSphere.material.colorWrite = false; // ✅ don't render color
solidSphere.material.depthWrite = false; // ✅ also skip depth buffer
solidSphere.material.stencilWrite = true;
solidSphere.material.stencilFunc = THREE.AlwaysStencilFunc;
solidSphere.material.stencilRef = 1;
solidSphere.material.stencilZPass = THREE.ReplaceStencilOp;


connectorGroup = new THREE.Group();
connectorGroup.renderOrder = 1;

dotGroup = new THREE.Group();
dotGroup.renderOrder = 1;
animateGridFadeIn(); // ⬅️ Call it just once here


      const container = document.getElementById("globeContainer");
renderer = new THREE.WebGLRenderer({ antialias: true, stencil: true });
renderer.autoClearStencil = false; // ⬅️ This is crucial
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

// Fix camera aspect ratio:
camera.aspect = container.clientWidth / container.clientHeight;
camera.updateProjectionMatrix();

unifiedGroup.add(connectorGroup);
unifiedGroup.add(dotGroup);

      document.addEventListener('mousemove', (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  if (isDragging) {
    const deltaX = event.movementX;
    const deltaY = event.movementY;

    targetRotationY += deltaX * 0.005;
    targetRotationX += deltaY * 0.005;

    trackingTarget = false; // stop tracking when manually rotating
    zoomLevel = 300;        // reset zoom if rotating manually
  }
});

      const globeContainer = document.getElementById("globeContainer");

globeContainer.addEventListener('mousedown', (e) => {
  isDragging = true;
  previousMousePosition = { x: e.clientX, y: e.clientY };
  tracking = false;
trackingInterrupted = true;
trackingProgress = 0;
});

globeContainer.addEventListener('mouseup', () => {
  isDragging = false;
});

globeContainer.addEventListener('mouseleave', () => {
  isDragging = false;
  tracking = false;
trackingInterrupted = true;
trackingProgress = 0;
});

        globeContainer.addEventListener('wheel', (e) => {
  e.preventDefault(); // prevent page scroll
  tracking = false;
  trackingInterrupted = true;
  trackingProgress = 0;

  // Scroll gesture → rotate the globe
  targetRotationY += e.deltaX * 0.002;
  targetRotationX += e.deltaY * 0.002;
}, { passive: false });
      
let cameraTargetPos = new THREE.Vector3();
let cameraTargetLook = new THREE.Vector3();

renderer.domElement.addEventListener('click', () => {
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObject(targetDot, false);

  if (intersects.length > 0) {
    tracking = true;
    trackingInterrupted = false;
    trackingProgress = 0;

    // Figure out initial camera positioning relative to dot
    const worldPos = targetDot.getWorldPosition(new THREE.Vector3());
    const offset = new THREE.Vector3().subVectors(camera.position, new THREE.Vector3(0, 0, 0));

    cameraTargetLook.copy(new THREE.Vector3(0, 0, 0));
    cameraTargetPos.copy(worldPos.clone().normalize().multiplyScalar(220)); // closer zoom
  }
});


      // Floating target dot
const targetDotGeometry = new THREE.SphereGeometry(3, 12, 12);
const targetDotMaterial = new THREE.MeshBasicMaterial({
  color: 0xffcc88,
  transparent: false,
  opacity: 1.0,
  transparent: false,
opacity: 1.0,
blending: THREE.NormalBlending,
depthWrite: true,
depthTest: true
});
targetDotMaterial.depthTest = false;
targetDot = new THREE.Mesh(targetDotGeometry, targetDotMaterial);
pivotGroup = new THREE.Group();
dotGroup.add(pivotGroup); // << attaches pivot to dotGroup so it rotates with view
pivotGroup.add(targetDot); // << attaches the dot to the pivot group
      targetDot.position.set(110, 0, 0); // radius from center, starting on the X-axis
targetDot.visible = false; // init state

// Orbit path visualization
const orbitPoints = [];
const segments = 64;
for (let i = 0; i <= segments; i++) {
  const angle = (i / segments) * Math.PI * 2;
  orbitPoints.push(new THREE.Vector3(
    orbitRadius * Math.cos(angle),
    0,
    orbitRadius * Math.sin(angle)
  ));
}
const orbitGeom = new THREE.BufferGeometry().setFromPoints(orbitPoints);
const orbitMat = new THREE.LineDashedMaterial({
  color: 0xffcc88,
  dashSize: 4,
  gapSize: 3,
  opacity: 1.0,
  transparent: false,
blending: THREE.NormalBlending,
depthWrite: true,
depthTest: true
});
      applyStencilMask(orbitMat);
orbitLine = new THREE.Line(orbitGeom, orbitMat);
orbitLine.computeLineDistances();
orbitLine.visible = false;
dotGroup.add(orbitLine);

      const totalDots = 220;
      const r = 100;
      let positions = [];

      for (let i = 0; i < totalDots; i++) {
        const offset = 2 / totalDots;
        const increment = Math.PI * (3 - Math.sqrt(5));
        const y = i * offset - 1 + (offset / 2);
        const radius = Math.sqrt(1 - y * y);
        const theta = i * increment;

        const x = r * radius * Math.cos(theta);
        const z = r * radius * Math.sin(theta);
        positions.push(new THREE.Vector3(x, y * r, z));
      }

      positions = positions.sort(() => Math.random() - 0.5);

      positions.forEach(pos => {
        scanTargets.push(pos);

        const dotGeometry = new THREE.SphereGeometry(1.8, 6, 6);
        const dotMaterial = new THREE.MeshBasicMaterial({
  color: dotColor.clone(),
  transparent: false,
  opacity: 1.0,
  blending: THREE.NormalBlending,
  depthWrite: true,
  depthTest: true
});
        applyStencilMask(dotMaterial);
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        dot.position.copy(pos);
        dot.visible = false;
        sphereDots.push(dot);
        dotGroup.add(dot);

        const direction = pos.clone();
        const scanGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          direction
        ]);
        const scanMaterial = new THREE.LineBasicMaterial({
  color: 0xff3300,
  transparent: false,
  opacity: 1.0,
  depthWrite: true,
  depthTest: true,
  blending: THREE.NormalBlending
});
        applyStencilMask(scanMaterial);
        const scanLine = new THREE.Line(scanGeometry, scanMaterial);
        scanLine.visible = false;
        scanLines.push({ 
  line: scanLine, 
  start: new THREE.Vector3(0, 0, 0), 
  end: direction.clone(), 
  target: dot 
});
        connectorGroup.add(scanLine);
      });

      scanLines = scanLines.sort(() => Math.random() - 0.5);

    scene.traverse(obj => {
  if (obj.isMesh || obj.isLine) {
    if (obj.material) {
      obj.material.side = THREE.FrontSide;
      obj.material.depthWrite = true;
      obj.material.depthTest = true;
    }
  }
});
      console.log('solidSphere', solidSphere);
console.log('renderOrder:', solidSphere.renderOrder);
console.log('depthWrite:', solidSphere.material.depthWrite);
console.log('opacity:', solidSphere.material.opacity);
console.log('transparent:', solidSphere.material.transparent);
    }

   function buildConnectorLinesAnimated(index = 0) {
  const batchSize = 6;

  if (index >= scanTargets.length) {
    // ✅ Dot only appears after connectors are fully built
    setTimeout(() => {
      targetDot.visible = true;
    }, 600);
    return;
  }

  if (index === 0) {
    scanTargets.sort((a, b) => a.y - b.y);
  }

  for (let i = 0; i < batchSize && index + i < scanTargets.length; i++) {
    const a = scanTargets[index + i];
    for (let j = 0; j < scanTargets.length; j++) {
      if (j === index + i) continue;
      const b = scanTargets[j];
      if (a.distanceTo(b) < 25) {
        const geom = new THREE.BufferGeometry().setFromPoints([a, b]);
        const mat = new THREE.LineBasicMaterial({ 
  color: 0x66ccff,
  transparent: false,
  opacity: 1.0,
  blending: THREE.NormalBlending,
  depthWrite: true,
  depthTest: true
});
applyStencilMask(mat);

        const conn = new THREE.Line(geom, mat);
        connectorGroup.add(conn);
        connectorLines.push(conn);
      }
    }
  }

  // Fast frame-based connector step
  setTimeout(() => buildConnectorLinesAnimated(index + batchSize), 5);
}


const lines = [
  "init_var=0xA1F3;",
  "sys.load(&core);",
  "while(!ready){scan++}",
  "αβΩ::protocol handshake",
  "ERROR 27 // ignored",
  "tracking.ping[✓✓✓]",
  "compiling::.....",
  "....locating signal....",
  "....data bleed....",
  "--RAM UNLOCKED--",
  "SYNC COMPLETE"
];

    const codeStream = document.getElementById("codeStream");

    function simulateTerminalLine() {
    const rand = Math.random();

    if (rand < 0.3) {
      let percent = 0;
      const loadLine = setInterval(() => {
        if (percent >= 100) {
          clearInterval(loadLine);
          simulateTerminalLine();
        } else {
          const dots = '.'.repeat(Math.floor(percent / 5));
          const loading = ${dots}[${percent.toFixed(0)}%] ▌;
          const existing = codeStream.innerHTML.split('<br>');
          if (existing.length > 0) existing.pop();
          existing.push(loading);
          codeStream.innerHTML = existing.join('<br>');
          percent += 10 + Math.random() * 10;
        }
      }, 40); // faster tick
    } else {
      const newLine = lines[Math.floor(Math.random() * lines.length)] + ' ▌';
      const existing = codeStream.innerHTML.split('<br>');
      existing.push(newLine);
      if (existing.length > 10) existing.shift();
      codeStream.innerHTML = existing.join('<br>');
      setTimeout(simulateTerminalLine, Math.random() * 800 + 400); // tighter rhythm
    }
  }
    
    function animate() {
      requestAnimationFrame(animate);

renderer.clear();
renderer.render(solidSphere, camera);


      dotOrbitAngle += 0.00025;
pivotGroup.rotation.y = dotOrbitAngle;

      const pulseScale = 1 + Math.sin(Date.now() * 0.002) * weatherSignature.energy * 0.05;
unifiedGroup.scale.set(pulseScale, pulseScale, pulseScale);

      if (tracking) {
  const worldPos = targetDot.getWorldPosition(new THREE.Vector3());
        zoomLevel += (220 - zoomLevel) * 0.05; // target zoom when tracking
  const camOffset = worldPos.clone().normalize().multiplyScalar(zoomLevel);
  camera.position.lerp(camOffset, 0.08);
  camera.lookAt(0, 0, 0);
} else if (trackingInterrupted && trackingProgress < 1.0) {
  trackingProgress += 0.02;
        zoomLevel += (300 - zoomLevel) * 0.05; // return to default zoom smoothly
  const exitTarget = new THREE.Vector3(0, 0, zoomLevel);
  camera.position.lerp(exitTarget, 0.05);
  camera.lookAt(0, 0, 0);
} else {
  camera.position.set(0, 0, zoomLevel);
  camera.lookAt(0, 0, 0);
}

     scanLines.forEach(({ line }) => {
  if (line.visible && line.material.opacity > 0.05) {
    line.material.opacity *= 0.95;
  } else {
    line.visible = false;
  }
});

      if (scanStep === 0) {
  const launchInterval = setInterval(() => {
    if (scanStep >= scanLines.length) {
      clearInterval(launchInterval);
      return;
    }

    const { line, target } = scanLines[scanStep];
    line.visible = true;
    line.material.opacity = 0.7;

    setTimeout(() => {
      document.documentElement.style.setProperty('--bg', theme.bg);
      document.documentElement.style.setProperty('--text', theme.text);
      document.documentElement.style.setProperty('--glow', theme.glow);

      if (target) {
        target.visible = true;

        const targetTypes = ['ASTEROID', 'PLANET', 'CONSTELLATION', 'SPACE STATION'];
        const type = targetTypes[Math.floor(Math.random() * targetTypes.length)];
        const name = type === 'PLANET' ? 'MARS' :
                     type === 'CONSTELLATION' ? 'ORION' :
                     type === 'SPACE STATION' ? 'ISS' : 'CERES-' + Math.floor(Math.random() * 99);

        // you can set UI text here if needed
      }
    }, 100);

    scanStep++;
    if (scanStep === scanLines.length && !connectorLinesBuilt) {
  buildConnectorLinesAnimated();
  connectorLinesBuilt = true;

  // Delay enabling front-face hiding until everything is done
  setTimeout(() => {
    enableFrontCull = true;
  }, 1000); // 1 second delay after connectors are built
}
  }, 16);
}

      if (colorUpdateActive) {
        let allReached = true;
        sphereDots.forEach(dot => {
          dot.material.color.lerp(targetDotColor, 0.05);
          if (!dot.material.color.equals(targetDotColor)) allReached = false;
        });
        if (allReached) colorUpdateActive = false;
      }

      const baseRotate = 0.0004 + weatherSignature.energy * 0.001;
const jitter = (Math.random() - 0.5) * weatherSignature.jitter * 0.01;

unifiedGroup.rotation.y += (targetRotationY - unifiedGroup.rotation.y) * 0.05 + baseRotate + jitter;
unifiedGroup.rotation.x += (targetRotationX - unifiedGroup.rotation.x) * 0.05 + baseRotate + jitter;

      if (connectorLinesBuilt && scanStep === scanLines.length) {
        targetRotationY += autoRotateY;
        targetRotationX += autoRotateX;
      }

const targetWorldPos = new THREE.Vector3();
targetDot.getWorldPosition(targetWorldPos);
const toCamera = camera.position.clone().sub(targetWorldPos).normalize();
const facing = targetWorldPos.clone().normalize().dot(toCamera);

targetDot.visible = facing > 0;
const alertUI = document.getElementById('foreignAlert');

if (!targetDot.visible) {
  const screenPos = targetWorldPos.clone().project(camera);
  const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

  const edgeX = Math.min(Math.max(x, 20), window.innerWidth - 150);
  const edgeY = Math.min(Math.max(y, 20), window.innerHeight - 50);

  alertUI.style.left = ${edgeX}px;
  alertUI.style.top = ${edgeY}px;
  alertUI.classList.remove('hidden');
} else {
  alertUI.classList.add('hidden');
}


      // Hover detection on targetDot
raycaster.setFromCamera(mouse, camera);
let intersects = raycaster.intersectObject(targetDot, false);

const ui = document.getElementById('targetUI');

  
const screenPos = targetDot.getWorldPosition(new THREE.Vector3()).project(camera);
const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

ui.style.left = ${x + 12}px;
ui.style.top = ${y - 30}px;

if (tracking) {
  orbitLine.visible = true;
  ui.classList.remove('hidden');
} else {
  orbitLine.visible = false;
  ui.classList.add('hidden');
}
      
if (enableFrontCull) {
  const camPos = camera.getWorldPosition(new THREE.Vector3());

  // Cull dots
  sphereDots.forEach(dot => {
    const worldPos = dot.getWorldPosition(new THREE.Vector3());
    const toCamera = camPos.clone().sub(worldPos).normalize();
    const fromCenter = worldPos.clone().normalize();
    dot.visible = toCamera.dot(fromCenter) > 0;
  });

  // Cull connector lines
  connectorLines.forEach(line => {
    const posAttr = line.geometry.getAttribute('position');
    const startLocal = new THREE.Vector3().fromBufferAttribute(posAttr, 0);
    const endLocal = new THREE.Vector3().fromBufferAttribute(posAttr, 1);

    line.updateMatrixWorld();

    const startWorld = startLocal.clone().applyMatrix4(line.matrixWorld);
    const endWorld = endLocal.clone().applyMatrix4(line.matrixWorld);

    const toCameraStart = camPos.clone().sub(startWorld).normalize();
    const toCameraEnd = camPos.clone().sub(endWorld).normalize();

    const facingStart = toCameraStart.dot(startWorld.clone().normalize());
    const facingEnd = toCameraEnd.dot(endWorld.clone().normalize());

    line.visible = facingStart > 0 && facingEnd > 0;
  });
}
      
renderer.render(scene, camera); // ← THIS GOES OUTSIDE tracking block
    }

    document.getElementById("loadingScreen").style.display = "flex";
simulateTerminalLine();

setInterval(getWeatherVisuals, 1000 * 60 * 30);

cycleLoadingText(() => {
  document.getElementById("loadingScreen").style.display = "none";
  getWeatherVisuals().then(() => {
    init();
    animate();
  });
});
  </script>
</body>
</html>
