<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Retro Ship Scan Interface - Three.js</title>
  <style>
    :root {
      --bg: #000000;
      --glow: #ffaa00;
      --text: #ffaa00;
    }

 .target-ui {
  position: absolute;
  background: rgba(0, 0, 0, 0.75);
  border: 1px solid var(--glow);
  padding: 6px 10px;
  font-family: 'IBM Plex Mono', monospace;
  font-size: 11px;
  pointer-events: none;
  color: var(--text);
  text-shadow: 0 0 3px var(--glow);
  z-index: 1001;
  display: none;
  animation: glitch-pulse 0.5s infinite steps(2, end);
}

@keyframes glitch-pulse {
  0%   { opacity: 0.9; transform: translate(0, 0); }
  25%  { transform: translate(1px, -1px); }
  50%  { transform: translate(-1px, 1px); }
  75%  { transform: translate(1px, 1px); }
  100% { opacity: 0.9; transform: translate(0, 0); }
}

.target-ui.hidden {
  display: none;
}

    .overlay {
  opacity: 0;
  transition: opacity 0.5s ease;
}


.target-label {
  font-size: 10px;
  letter-spacing: 0.15em;
  opacity: 0.7;
}

.target-type {
  font-size: 14px;
  margin-top: 4px;
  font-weight: bold;
}

    .target-ui {
  left: 0;
  top: 0;
}


.target-name {
  font-size: 18px;
  margin-top: 2px;
}

.target-info {
  font-size: 12px;
  margin-top: 4px;
  opacity: 0.8;
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
  50% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
}

    body {
      margin: 0;
      background: var(--bg);
      overflow: hidden;
      font-family: 'IBM Plex Mono', monospace;
      color: var(--text);
      transition: background 1.5s ease, color 1.5s ease;
    }

    canvas {
      display: block;
      filter: drop-shadow(0 0 12px var(--glow));
      transition: filter 1.5s ease;
    }

    .overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 14px;
      color: var(--text);
      text-shadow: 0 0 4px var(--glow);
      transition: color 1.5s ease, text-shadow 1.5s ease;
      z-index: 1000;
    }

    #codeStream {
      color: var(--text);
      text-shadow: 0 0 1px var(--glow);
      font-size: 4px;
      opacity: 0.9;
      font-family: 'IBM Plex Mono', monospace;
      position: fixed;
      bottom: 6px;
      left: 6px;
      z-index: 1000;
      max-width: 140px;
      overflow: hidden;
      text-align: left;
    }

    #loadingScreen {
  background: #000;
  color: #ffaa00;
  font-family: 'IBM Plex Mono', monospace;
  letter-spacing: 0.15em;
  font-size: 12px;
  text-shadow: 0 0 4px #ffaa00;
  animation: flicker 1s infinite;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 9999;
  pointer-events: none;
}

@keyframes flicker {
  0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
    opacity: 1;
  }
  20%, 24%, 55% {
    opacity: 0.5;
  }
}

#progressBarContainer {
  width: 240px;
  height: 8px;
  border: 1px solid var(--glow);
  box-shadow: 0 0 3px var(--glow);
  background: linear-gradient(to right, rgba(255,170,0,0.1) 0%, rgba(0,0,0,0.1) 100%);
  margin-top: 20px;
  position: relative;
  overflow: hidden;
}

#progressBar {
  width: 0%;
  height: 100%;
  background: var(--glow);
  box-shadow: 0 0 12px var(--glow), 0 0 2px var(--glow) inset;
  transition: width 0.25s ease;
}

#loadingText {
  font-size: 12px;
  letter-spacing: 0.15em;
  color: var(--text);
  text-shadow: 0 0 3px var(--glow);
}

    @keyframes glyph-spin {
      0%   { transform: scale(1) rotate(0deg); opacity: 0.6; }
      25%  { transform: scale(1.2) rotate(8deg); opacity: 1; }
      50%  { transform: scale(1) rotate(-8deg); opacity: 0.6; }
      75%  { transform: scale(1.1) rotate(4deg); opacity: 1; }
      100% { transform: scale(1) rotate(0deg); opacity: 0.6; }
    }
  </style>
</head>
<body>
  <div class="overlay">
    INTERFACE ONLINE...<br>
    TRACKING OBJECT<br>
    SIGNAL LOCKED<br>
    UNIT ID: A7-SCAN<br>
  </div>

  <div id="loadingScreen">
  <div id="loadingText">⚡ BOOTING SEQUENCE...</div>
  <div id="progressBarContainer">
    <div id="progressBar"></div>
  </div>
</div>

  <div id="targetUI" class="target-ui hidden">
  <div class="target-label">TARGET LOCKED</div>
  <div class="target-type">[ TYPE: ASTEROID ]</div>
  <div class="target-name">CERES-9</div>
  <div class="target-info">DISTANCE: 41,000 KM</div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    let scene, camera, renderer, scanLines = [], scanStep = 0;
let sphereDots = [], scanTargets = [], connectorGroup, dotGroup;
let mouseX = 0, mouseY = 0, targetRotationX = 0, targetRotationY = 0;
let autoRotateY = 0.0015;
let autoRotateX = 0.00075;
let dotColor = new THREE.Color(0xffaa00);
let targetDotColor = dotColor.clone();
let connectorLinesBuilt = false;
let colorUpdateActive = false;
let theme;

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let targetDot; // 🛠️ Add this

    
 const loadingTexts = [
  "POWER SUPPLY OK",
  "CPU DIAGNOSTIC... PASSED",
  "MEMORY BANKS... OK",
  "VGA INTERFACE... OK",
  "INITIATING BOOT SEQUENCE...",
  "LOADING OS KERNEL",
  "ACTIVATING SENSOR ARRAY",
  "CREATING DIGITAL ATMOSPHERE...",
  "ATMOSPHERE STABILIZED",
  "CALIBRATING OPTICS...",
  "OPTICS ALIGNED",
  "INITIATING WEATHER SCAN...",
  "SCANNING CLIMATE DATA",
  "PARSING METEOROLOGICAL READINGS...",
  "SCAN COMPLETE!",
  "INITIALIZING OBJECT SCAN...",
  "DETECTING FOREIGN OBJECTS...",
  "OBJECT SCAN: 38 TARGETS FOUND",
  "INITIALIZING PLANET LOAD...",
  "STELLAR COORDINATES LOCKED",
  "GRAVITY FIELD MAPPED",
  "NAV SYSTEM ONLINE",
  "STARTING UP...",
  "LOADING INTERFACE MODULE",
  "RENDER ENGINE READY",
  "FINAL SYSTEM CHECK...",
  "PROCESS COMPLETE"
];

    function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

let loadingTextInterval;

function cycleLoadingText(callback) {
  const loadingTextElement = document.getElementById("loadingText");
  const bar = document.getElementById("progressBar");

  let index = 0;
  const total = loadingTexts.length;

  function next() {
    if (index >= total) {
      bar.style.width = `100%`; // force complete
      if (callback) callback();
      return;
    }

    loadingTextElement.textContent = loadingTexts[index];
    bar.style.width = `${((index + 1) / total) * 100}%`;

    index++;
    setTimeout(next, 80); // 🟠 even faster, ~2s full run
  }

  next();
}
    
function simulateProgressBar(duration = 3600) {
  return new Promise((resolve) => {
    const bar = document.getElementById("progressBar");
    let start = null;

    function animate(timestamp) {
      if (!start) start = timestamp;
      const progress = Math.min((timestamp - start) / duration, 1);
      bar.style.width = `${progress * 100}%`;

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        resolve(); // Done!
      }
    }

    requestAnimationFrame(animate);
  });
}


    function getWeatherVisuals() {
      return fetch("https://ipapi.co/json/")
        .then(loc => loc.json())
        .then(location => {
          const city = location.city;
          return fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=d8c57f566aee63e2c23b71a879a8d2b7&units=metric`);
        })
        .then(res => res.json())
        .then(data => {
          const hour = new Date().getHours();
          const isNight = hour < 6 || hour >= 22;
          const isMidday = hour >= 11 && hour <= 15;
          const condition = data.weather[0].main.toLowerCase();
          const wind = data.wind.speed;
          const pressure = data.main.pressure;
          const clouds = data.clouds.all;

          let calmScore = 0.5;
          if (isNight) calmScore += 0.3;
          if (isMidday) calmScore -= 0.2;
          if (["thunderstorm", "rain", "storm"].includes(condition)) calmScore -= 0.5;
          if (condition === "clear") calmScore += 0.2;
          if (clouds > 70) calmScore -= 0.1;
          if (pressure > 1020) calmScore += 0.1;
          calmScore = Math.min(Math.max(calmScore, 0), 1);

          let motionScore = wind / 15;
          if (condition === "clear") motionScore *= 0.5;
          motionScore = Math.min(Math.max(motionScore, 0), 1);

          let moodColorScore = 0.5;
          if (condition === "clear" && !isNight) moodColorScore = 0.2;
          if (condition === "rain") moodColorScore = 0.7;
          if (condition === "thunderstorm") moodColorScore = 1.0;
          if (["fog", "snow"].includes(condition)) moodColorScore = 0.3;

          autoRotateY = 0.0005 + motionScore * 0.002;
          autoRotateX = 0.00025 + motionScore * 0.001;

          // Set target dot color based on moodColorScore
          if (moodColorScore < 0.3) targetDotColor.set(0xffffff);
          else if (moodColorScore < 0.6) targetDotColor.set(0xffaa00);
          else if (moodColorScore < 0.85) targetDotColor.set(0xff5522);
          else targetDotColor.set(0xff2200);

          colorUpdateActive = true; // trigger color lerping in animate()

          if (isNight) {
            theme.bg = '#020714';
            theme.text = '#99ccff';
            theme.glow = '#66ccff';
          } else if (condition === 'clear') {
            theme.bg = '#1a0d00';
            theme.text = '#ffe0a3';
            theme.glow = '#ffcc66';
          } else if (condition === 'clouds') {
            theme.bg = '#1a1a1a';
            theme.text = '#ff9900';
            theme.glow = '#cc7700';
          } else if (condition === 'rain') {
            theme.bg = '#0d0d14';
            theme.text = '#ff5533';
            theme.glow = '#ff3300';
          } else if (condition === 'thunderstorm') {
            theme.bg = '#1a0000';
            theme.text = '#ff2200';
            theme.glow = '#ff0000';
          } else if (["fog", "mist", "snow"].includes(condition)) {
            theme.bg = '#10161a';
            theme.text = '#e0e0e0';
            theme.glow = '#cccccc';
          }

          document.documentElement.style.setProperty('--bg', theme.bg);
          document.documentElement.style.setProperty('--text', theme.text);
          document.documentElement.style.setProperty('--glow', theme.glow);

          console.log("🌈 THEME APPLIED", theme);
        });
    }

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
      camera.position.z = 300;

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      connectorGroup = new THREE.Group();
      dotGroup = new THREE.Group();
      scene.add(connectorGroup);
      scene.add(dotGroup);

      document.addEventListener('mousemove', (event) => {
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  if (!connectorLinesBuilt) return;
  mouseX = mouse.x;
  mouseY = mouse.y;
  targetRotationY = mouseX * 0.5;
  targetRotationX = mouseY * 0.5;
});


      // Floating target dot
const targetDotGeometry = new THREE.SphereGeometry(3.2, 8, 8);
const targetDotMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
targetDot = new THREE.Mesh(targetDotGeometry, targetDotMaterial);
scene.add(targetDot);

      const totalDots = 220;
      const r = 100;
      let positions = [];

      for (let i = 0; i < totalDots; i++) {
        const offset = 2 / totalDots;
        const increment = Math.PI * (3 - Math.sqrt(5));
        const y = i * offset - 1 + (offset / 2);
        const radius = Math.sqrt(1 - y * y);
        const theta = i * increment;

        const x = r * radius * Math.cos(theta);
        const z = r * radius * Math.sin(theta);
        positions.push(new THREE.Vector3(x, y * r, z));
      }

      positions = positions.sort(() => Math.random() - 0.5);

      positions.forEach(pos => {
        scanTargets.push(pos);

        const dotGeometry = new THREE.SphereGeometry(1.8, 6, 6);
        const dotMaterial = new THREE.MeshBasicMaterial({ color: dotColor.clone() });
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        dot.position.copy(pos);
        dot.visible = false;
        sphereDots.push(dot);
        dotGroup.add(dot);

        const direction = pos.clone();
        const scanGeometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          direction
        ]);
        const scanMaterial = new THREE.LineBasicMaterial({
          color: 0xff3300,
          transparent: true,
          opacity: 0.7,
          depthWrite: false,
          blending: THREE.AdditiveBlending
        });
        const scanLine = new THREE.Line(scanGeometry, scanMaterial);
        scanLine.visible = false;
        scanLines.push({ line: scanLine, target: dot });
        scene.add(scanLine);
      });

      scanLines = scanLines.sort(() => Math.random() - 0.5);
    }

    function buildConnectorLinesAnimated(index = 0) {
      if (index >= scanTargets.length) return;

      if (index === 0) {
        scanTargets.sort((a, b) => a.y - b.y);
      }

      const a = scanTargets[index];
      for (let j = 0; j < scanTargets.length; j++) {
        if (j === index) continue;
        const b = scanTargets[j];
        if (a.distanceTo(b) < 25) {
          const geom = new THREE.BufferGeometry().setFromPoints([a, b]);
          const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
          const conn = new THREE.Line(geom, mat);
          conn.visible = true;
          connectorGroup.add(conn);
        }
      }

      setTimeout(() => buildConnectorLinesAnimated(index + 1), 1);
    }

    function animate() {
      requestAnimationFrame(animate);

      if (scanStep === 0) {
  const launchInterval = setInterval(() => {
    if (scanStep >= scanLines.length) {
      clearInterval(launchInterval);
      return;
    }

    const { line, target } = scanLines[scanStep];
    line.visible = true;

    setTimeout(() => {
      document.documentElement.style.setProperty('--bg', theme.bg);
      document.documentElement.style.setProperty('--text', theme.text);
      document.documentElement.style.setProperty('--glow', theme.glow);

      if (target) {
        target.visible = true;

        const targetTypes = ['ASTEROID', 'PLANET', 'CONSTELLATION', 'SPACE STATION'];
        const type = targetTypes[Math.floor(Math.random() * targetTypes.length)];
        const name = type === 'PLANET' ? 'MARS' :
                     type === 'CONSTELLATION' ? 'ORION' :
                     type === 'SPACE STATION' ? 'ISS' : 'CERES-' + Math.floor(Math.random() * 99);

        // you can set UI text here if needed
      }
    }, 100);

    scanStep++;
    if (scanStep === scanLines.length && !connectorLinesBuilt) {
      buildConnectorLinesAnimated();
      connectorLinesBuilt = true;
    }
  }, 60);
}

      if (colorUpdateActive) {
        let allReached = true;
        sphereDots.forEach(dot => {
          dot.material.color.lerp(targetDotColor, 0.05);
          if (!dot.material.color.equals(targetDotColor)) allReached = false;
        });
        if (allReached) colorUpdateActive = false;
      }

      connectorGroup.rotation.y += (targetRotationY - connectorGroup.rotation.y) * 0.05 + autoRotateY;
      connectorGroup.rotation.x += (targetRotationX - connectorGroup.rotation.x) * 0.05 + autoRotateX;
      dotGroup.rotation.y = connectorGroup.rotation.y;
      dotGroup.rotation.x = connectorGroup.rotation.x;

      if (connectorLinesBuilt && scanStep === scanLines.length) {
        targetRotationY += autoRotateY;
        targetRotationX += autoRotateX;
      }
     
const t = Date.now() * 0.001;
const orbitRadius = 110;
targetDot.position.x = orbitRadius * Math.cos(t * 0.2);
targetDot.position.y = 20 + Math.sin(t * 0.5) * 8;
targetDot.position.z = orbitRadius * Math.sin(t * 0.2);

      // Hover detection on targetDot
raycaster.setFromCamera(mouse, camera);
let intersects = raycaster.intersectObject(targetDot);

const ui = document.getElementById('targetUI');

if (intersects.length > 0) {
  // Project 3D position to 2D screen space
  const screenPos = targetDot.position.clone().project(camera);
  const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
  const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;

  ui.style.left = `${x + 12}px`;
  ui.style.top = `${y - 30}px`;

  ui.querySelector('.target-type').textContent = '[ TYPE: COMET ]';
  ui.querySelector('.target-name').textContent = 'HALLEY-84';
  ui.querySelector('.target-info').textContent = 'DISTANCE: 38,400 KM';

  ui.classList.remove('hidden');
} else {
  ui.classList.add('hidden');
}

      renderer.render(scene, camera);
    }

    document.getElementById("loadingScreen").style.display = "flex";
cycleLoadingText();

const MIN_LOAD_TIME = 3000;
const loadStart = Date.now();

    setInterval(getWeatherVisuals, 1000 * 60 * 30);
    simulateTerminalLine();
    bootSequence();
  </script>

  <pre id="codeStream"></pre>
  <script>
  const codeStream = document.getElementById("codeStream");
  const lines = [
    "init_var=0xA1F3;",
    "sys.load(&core);",
    "while(!ready){scan++}",
    "αβΩ::protocol handshake",
    "ERROR 27 // ignored",
    "tracking.ping[✓✓✓]",
    "compiling::.....",
    "....locating signal....",
    "....data bleed....",
    "--RAM UNLOCKED--",
    "SYNC COMPLETE"
  ];

  function simulateTerminalLine() {
    const rand = Math.random();

    if (rand < 0.3) {
      let percent = 0;
      const loadLine = setInterval(() => {
        if (percent >= 100) {
          clearInterval(loadLine);
          simulateTerminalLine();
        } else {
          const dots = '.'.repeat(Math.floor(percent / 5));
          const loading = `${dots}[${percent.toFixed(0)}%] ▌`;
          const existing = codeStream.innerHTML.split('<br>');
          if (existing.length > 0) existing.pop();
          existing.push(loading);
          codeStream.innerHTML = existing.join('<br>');
          percent += 10 + Math.random() * 10;
        }
      }, 40); // faster tick
    } else {
      const newLine = lines[Math.floor(Math.random() * lines.length)] + ' ▌';
      const existing = codeStream.innerHTML.split('<br>');
      existing.push(newLine);
      if (existing.length > 10) existing.shift();
      codeStream.innerHTML = existing.join('<br>');
      setTimeout(simulateTerminalLine, Math.random() * 800 + 400); // tighter rhythm
    }
  }

async function bootSequence() {
  const loadingScreen = document.getElementById("loadingScreen");
  const progressBar = document.getElementById("progressBar");

  loadingScreen.style.display = "flex";

  await new Promise((resolve) => cycleLoadingText(resolve));
  await delay(100); // tiny pause

  await getWeatherVisuals();
  init();

  // ⏳ Fade out + clean remove
  loadingScreen.style.transition = "opacity 0.5s ease";
  loadingScreen.style.opacity = "0";

  await delay(600); // wait for fade to finish

  progressBar.style.display = "none";
  loadingScreen.remove(); // Fully remove from DOM
  document.querySelector(".overlay").style.opacity = "1";
  animate();
  simulateTerminalLine();
}
</script>
</body>
</html>
